"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IMDBTitleSearchResolver = void 0;
const constants_1 = require("../constants");
const ResolverCacheManager_1 = require("../utils/ResolverCacheManager");
const cheerio_1 = require("cheerio");
const formatHTMLText_1 = require("../utils/formatHTMLText");
const enums_1 = require("../enums");
const convertIMDBPathToIMDBUrl_1 = require("../utils/convertIMDBPathToIMDBUrl");
const extractIMDBIdFromUrl_1 = require("../utils/extractIMDBIdFromUrl");
const requestClient_1 = require("../requestClient");
class IMDBTitleSearchResolver {
    constructor(queryName, { exactMatch = false, specificType, } = {}) {
        this.resolverCacheManager = new ResolverCacheManager_1.ResolverCacheManager();
        this.queryName = queryName;
        this.exactMatch = exactMatch;
        this.specificType = specificType;
    }
    async getResult() {
        await this.loadSearchPageHTMLData();
        const allTypesResultList = this.originalResultList;
        // do sort and filters
        const finalResult = allTypesResultList
            .filter((i) => 
        //  filter specific types
        this.specificType ? i.titleType === this.specificType : true)
            .sort((a, b) => b.matchScore - a.matchScore);
        return finalResult;
    }
    async loadSearchPageHTMLData() {
        const { nameWithoutYear } = this.nameWithoutYearAndRequestedYearFromQuery;
        // getting result from imdb page by http request
        const result = await (0, requestClient_1.getRequest)(constants_1.IMDB_TITLE_SEARCH_URL, {
            q: nameWithoutYear,
            exact: this.exactMatch,
            s: "tt",
            ref: "fn_tt_ex",
        });
        // parse page content for jquery like
        this.searchPageHTMLData = result.data;
        this.searchPageCheerio = (0, cheerio_1.load)(this.searchPageHTMLData);
    }
    get nameWithoutYearAndRequestedYearFromQuery() {
        const cacheDataManager = this.resolverCacheManager.load("getNameWithoutYearAndRequestedYearFromQuery");
        if (cacheDataManager.hasData) {
            return cacheDataManager.data;
        }
        const queryName = this.queryName;
        const nameExecDetails = /^(.{1,150})\s(\d{4})\s*$/.exec(queryName);
        let nameWithoutYear, requestedYear = null;
        nameWithoutYear = queryName;
        if (Array.isArray(nameExecDetails)) {
            nameWithoutYear = nameExecDetails[1];
            requestedYear = Number(nameExecDetails[2]);
        }
        return { nameWithoutYear, requestedYear };
    }
    get originalResultList() {
        const $ = this.searchPageCheerio;
        const isType1 = !!$("[data-testid='find-results-section-title']")
            .first()
            .find(".find-title-result").length;
        if (isType1) {
            return this.originalResultListType1;
        }
        return this.originalResultListType2;
    }
    get originalResultListType1() {
        const moviesList = [];
        const { nameWithoutYear, requestedYear } = this.nameWithoutYearAndRequestedYearFromQuery;
        const $ = this.searchPageCheerio;
        const queryName = this.queryName;
        // find rows of result (jquery like) and push it with proper format to result list
        $("[data-testid='find-results-section-title']")
            .first()
            .find(".find-title-result")
            .each(function (index) {
            // exclude vars from result row
            const $this = $(this);
            const name = (0, formatHTMLText_1.formatHTMLText)($this.find(".ipc-metadata-list-summary-item__t").text());
            const aka = index == 0 ? queryName : "";
            const desc = (0, formatHTMLText_1.formatHTMLText)($this.find(".ipc-metadata-list-summary-item__tl").text());
            const titleType = /.*episode.*\s*$/i.test(desc)
                ? enums_1.TitleMainType.SeriesEpisode
                : /.*series.*\s*$/i.test(desc)
                    ? enums_1.TitleMainType.Series
                    : enums_1.TitleMainType.Movie;
            const titleYear = Number(/-(\d{4})/.exec(desc)?.[1] || /(\d{4})/.exec(desc)?.[1] || "");
            const url = (0, convertIMDBPathToIMDBUrl_1.convertIMDBPathToIMDBUrl)($this.find("a").first().attr("href"));
            // calculate match score - for sorting results
            let matchScore = 0;
            if (index < 4) {
                matchScore += 6 - index * 2;
            }
            if (name === nameWithoutYear || aka === nameWithoutYear) {
                matchScore += 4;
            }
            if (titleYear && requestedYear === titleYear) {
                matchScore += 4;
            }
            if ([enums_1.TitleMainType.Movie, enums_1.TitleMainType.Series].includes(titleType)) {
                matchScore += 3;
            }
            // push to the final list
            moviesList.push({
                source: {
                    sourceId: (0, extractIMDBIdFromUrl_1.extractIMDBIdFromUrl)(url, "tt"),
                    sourceType: enums_1.Source.IMDB,
                    sourceUrl: url,
                },
                name,
                aka,
                titleYear,
                url,
                titleType,
                matchScore,
                thumbnailImageUrl: $this.find("img.ipc-image").first().attr("src") ?? "",
            });
        });
        return moviesList.slice(0, 25);
    }
    get originalResultListType2() {
        const moviesList = [];
        const { nameWithoutYear, requestedYear } = this.nameWithoutYearAndRequestedYearFromQuery;
        const $ = this.searchPageCheerio;
        // find rows of result (jquery like) and push it with proper format to result list
        $("table.findList")
            .first()
            .find("tr")
            .each(function (index) {
            // exclude vars from result row
            const $this = $(this);
            const $movieTexts = $this.find("td:eq(1)");
            const text = (0, formatHTMLText_1.formatHTMLText)($movieTexts.text());
            const name = (0, formatHTMLText_1.formatHTMLText)($movieTexts.find("a").text());
            const aka = (0, formatHTMLText_1.formatHTMLText)(/aka\s"(.+)"/.exec(text)?.[1]);
            const titleType = /(.*episode.*)\s*$/i.test(text)
                ? enums_1.TitleMainType.SeriesEpisode
                : /(.*series.*)\s*$/i.test(text)
                    ? enums_1.TitleMainType.Series
                    : enums_1.TitleMainType.Movie;
            const titleYear = Number(/(\d{4})/.exec(text)?.[1] || "");
            const url = (0, convertIMDBPathToIMDBUrl_1.convertIMDBPathToIMDBUrl)($movieTexts.find("a").attr("href"));
            // calculate match score - for sorting results
            let matchScore = 0;
            if (index < 4) {
                matchScore += 6 - index * 2;
            }
            if (name === nameWithoutYear || aka === nameWithoutYear) {
                matchScore += 4;
            }
            if (titleYear && requestedYear === titleYear) {
                matchScore += 4;
            }
            if ([enums_1.TitleMainType.Movie, enums_1.TitleMainType.Series].includes(titleType)) {
                matchScore += 3;
            }
            // push to the final list
            moviesList.push({
                source: {
                    sourceId: (0, extractIMDBIdFromUrl_1.extractIMDBIdFromUrl)(url, "tt"),
                    sourceType: enums_1.Source.IMDB,
                    sourceUrl: url,
                },
                name,
                aka,
                titleYear,
                url,
                titleType,
                matchScore,
                thumbnailImageUrl: $this.find("td").eq(0).find("img").first().attr("src") ?? "",
            });
        });
        return moviesList.slice(0, 25);
    }
}
exports.IMDBTitleSearchResolver = IMDBTitleSearchResolver;
